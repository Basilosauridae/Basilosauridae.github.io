---
title: Vue2核心源码解析
date: 2024-03-08
tags:
  - sourceCode
categories:
  - 前端开发
---

## Flow

### 是什么

一种静态检查工具，工作中不会用到，类似于Typescript。[Flow官网](https://flow.org/en/docs/getting-started/)

### 使用flow的原因

- Js是一个动态类型语言，灵活的背后带来的是难以寻找的bug;
- 类型检查时当前动态类型语言发展的趋势，帮助开发者在编译时发现由于类型错误引起的bug;
- 项目越复杂越需要通过工具的手段来保证项目的维护和代码的可读性。


:::info
可以看一下尤雨溪本人的解释：[知乎](https://www.zhihu.com/question/46397274/answer/101193678):

1. Vue 2.0 本身在初期的快速迭代阶段是用 ES2015 写的，整个构建工具链也沿用了 Vue 1.x 的基于 ES 生态的一套（Babel, ESLint, Webpack, Rollup...)
2. Babel和ESlint都有对应的Flow插件以及支持的语法。

:::

### Flow 在 Vue.js 源码中的应用

在Vue2的更早的版本中，[link](https://github.com/vuejs/vue/blob/2.6/.flowconfig),主目录下有` .flowconfig `文件，用于配置Flow.

Flow的`libdef`可以用于识别第三库或自定义类型。

## 源码学习思路

1. 了解核心流程API，把库的API用熟（顺藤摸瓜）
2. 整体执行流程，（lodash、underscore等工具库除外,无太多学习参考意义），如：
    - webpack/vite/gulp：从启动到打包输出的流程
    - Vue2：Vue2从编译 => 初始化 => 触发更新 => 卸载的流程
3. 看package.json，看依赖和命令

## Vue的目录结构设计
[源码](https://github.com/vuejs/vue)`src下`:

| 文件夹 | 内容 |
|-------|-------|
| compiler | 编译相关 |
| core | 核心代码 | 
| platforms | 解决跨平台 | 
| server | 服务端渲染 | 
| sfc | .vue文件解析 | 
| shared | 共享代码 | 

### compiler

> 补充知识：编译可以在构建时（借助webpack、vue-loader等辅助工具插件），也可以在运行时使用包含构建功能的Vue.js。编译时一项耗性能的工作，所以推荐前者————离线编译。（本篇文章中搜索👺）

Vue.js所有编译部分的代码。包括将模板解析成ast语法树，ast语法树优化，代码生成功能：🐰

- `vue2`中是通过正则方式实现，`vue3`更加严谨：通过状态机制来做tokens的解析，词法语法分析（也包括部分正则）；
- compiler/parser转换 => compiler/directive AST解析 => compiler/codergen 生成；
- 完整的编译过程：将代码转成 => AST => 目标AST => 生成代码


### core 

<xicons icon="Star" /> 核心代码，Vue.js的灵魂。

- core/observer 响应式部分，dep.ts侦听依赖内容，scheduler.ts调度
- core/instance 生命周期、proxy、初始化挂载等
- core/vdom 虚拟dom等

### platforms

Vue.js是跨平台的类`MVVM`框架，可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。多端适配处理，非重点。

![](https://cetacea-1304984885.cos.ap-shanghai.myqcloud.com/pieces/Snipaste_2024-03-15_18-49-48.jpg)

### server

- Vue2 支持了服务端渲染，这个目录下是所有服务端渲染的逻辑；
- 这个文件夹下的代码 是跑在服务端的 `Node.js`，不是跑在浏览器端的vue.js;
- 服务端渲染的主要工作是 将组件渲染为 服务端的HTML字符串，将他们直接发送到浏览器，最后`静态标记`混合为客户端上完全交互的应用程序。

### sfc

把`.vue`文件内容解析成一个 JS 对象。

### shared

定义一些工具方法，被浏览器和服务端的Vue.js共享。如生命周期hooks等。

## Vue源码构建

### 构建脚本和过程

Vue.js 源码是基于 `Rollup` 构建的，它的构建相关配置都在 scripts 目录下。

- 当在命令行运行 `npm run build` 的时候，实际上就会执行 node scripts/build.js

```js
//package.json
"build": "node scripts/build.js",
"build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
"build:weex": "npm run build -- weex",
```

- `scripts/build.js`：先从配置文件读取配置，再通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了
```js
let builds = require('./config').getAllBuilds()

// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
```
- 接下来我们看一下配置文件，在 `scripts/config.js` 中：
```js
const builds = {
  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.js'),
    format: 'cjs',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-cjs': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.common.js'),
    format: 'cjs',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime only (ES Modules). Used by bundlers that support ES Modules,
  // e.g. Rollup & Webpack 2
  'web-runtime-esm': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.esm.js'),
    format: 'es',
    banner
  },
  // Runtime+compiler CommonJS build (ES Modules)
  'web-full-esm': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.esm.js'),
    format: 'es',
    alias: { he: './entity-decoder' },
    banner
  },
  // runtime-only build (Browser)
  'web-runtime-dev': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler development build (Browser)
  'web-full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
  // Runtime+compiler production build  (Browser)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },
}
/*这里列举了一些 Vue.js 构建的配置，对于单个配置，它是遵循 Rollup 的构建规则的。
其中 entry 属性表示构建的入口 JS 文件地址，dest 属性表示构建后的 JS 文件地址。
format 属性表示构建的格式，cjs 表示构建出来的文件遵循 CommonJS 规范，
es 表示构建出来的文件遵循 ES Module 规范。 umd 表示构建出来的文件遵循 UMD 规范。*/
```
- 经过 Rollup 的构建打包后，最终会在 dist 目录下生成 dist/vue.runtime.common.dev.js。

### Runtime Only VS Runtime + Compiler 👺

vue-cli 去初始化我们的 Vue.js 项目的时候会询问我们用 `Runtime Only` 版本的还是 `Runtime + Compiler` 版本。下面我们来对比这两个版本。

- Runtime Only: 使用此版本的Vue.js,需借助 webpack 的 vue-loader 工具把 `.vue`文件编译成 JS, 因为是在编译阶段做的，所以代码体积更轻；

- Runtime + Compiler：如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板，如下所示：
  ```js
  // 需要编译器的版本
  new Vue({
    template: '<div>{{ hi }}</div>'
  })

  // 这种情况不需要
  new Vue({
    render (h) {
      return h('div', this.hi)
    }
  })
  ```
- Vue2.0中，最终渲染都是通过`render`函数，若写 template 属性，最终需编译成 render，那么这个编译过程发生运行时，需要带有编译器的版本。所以更推荐`Runtime Only`

## 根据执行过程分析源码

共九步。

### 1. 首先编写的是`.vue`文件

### 2. 用 sfc 将 `.vue` => `JS`

- [AST Explorer](https://astexplorer.net/),源码和这个语法一致。
- packages/compiler-sfc/src中, `compileScript、compileTemplate、compileStyle`方法解析

### 3. `compiler`用于编译处理

全文搜索🐰

### 4. 启动项目，初始化应用，new Vue()

（下面需补充）


4. 启动项目，初始化应用，new Vue() 
   - core/index.ts => core/global-api:`initGlobalAPI`:
      - initUse(Vue) - 初始化插件机制 - Vue.use(xxx)
      - initMixin(Vue) - Vue.mixin
      - initExtend(Vue) - 继承机制 - Vue.extend
      - initAssetRegisters(Vue) - vue2中，src/shared/constens.ts将资源(ASSET_TYPES)规定为三类（component、directive、filter），这里初始化是针对这个
5. 处理初始化逻辑，包含生命周期、Mixin等内容
   - core/instance/index.ts
6. 创建对应的`vdom`,挂载
   - core/instance/render.ts 挂载 => `creatElement` => core/vdom/create-elemnent.ts - 初始化创建的逻辑
7. 一旦发生更新,即data数据变更，通过监听触发
   - Vue2源码看老的版本，新版本大部分是Proxy重构；看这[主要逻辑](https://github.com/vuejs/vue/blob/1.1/src/observer/array.js)
   - [patch逻辑](https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts) - diff算法处理时：🚩
     ```js
     //🚩面试常问：Vue中 :key 的作用:score/vdom/patch.ts的第36行,尤雨溪定义了一个sameVnode方法，
     //根节点初筛，sameVnode 对key，tag，type等进行简单的判断，通过了就进行具体差异对比, 不通过就新建dom。
     /*作用总结：Vue响应式系统中，大量源码做性能优化的事情，其中就包含:key，在diff过程中，始终以最以最小代价、
       最大程度去进行节点复用（patch），
       而key就作为我们判断节点是否可以复用的一大标准（除了判断key相同 还有其他判断如💛）。
     */
     function sameVnode(a, b) {
      return (
        a.key === b.key && //key全等 这也是不能用index作为key的原因🚩
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&//💛
          a.isComment === b.isComment &&//💛
          isDef(a.data) === isDef(b.data) && //💛
          //data保存了元素上的属性 如attrs: { class: 'box' }, staticStyle: { color: 'red'}等
          //isDef作用： 判断值是否被定义
          sameInputType(a, b)) || //input type属性是否相同
          (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error)))
      )
     ```
8. 收集依赖
9. 处理更新diff

## Vue2 Diff算法

diff的目的：尽可能减少 dom 变更（reflow/repaint）,找到可以复用的节点

### 双端diff

双端比较就是新列表和旧列表两个列表的头与尾互相对比，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。

### 缺点

Vue2是全量 Diff (当数据发生变化，它就会发生一个DOM树，并和之前的DOM树比较，找到不同的节点然后更新)，如果层级很高，很消耗内存。

